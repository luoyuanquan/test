; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\OUTPUT\sys.o --depend=..\OUTPUT\sys.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OUTPUT\sys.crf ..\SYSTEM\sys\sys.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;23     //091207
;;;24     void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
000000  4aaf              LDR      r2,|L1.704|
;;;25     { 
;;;26       	//检查参数合法性
;;;27     	assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
;;;28     	assert_param(IS_NVIC_OFFSET(Offset));  	 
;;;29     	SCB->VTOR = NVIC_VectTab|(Offset & (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
000002  400a              ANDS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  4baf              LDR      r3,|L1.708|
000008  601a              STR      r2,[r3,#0]
;;;30     	//用于标识向量表是在CODE区还是在RAM区
;;;31     }
00000a  4770              BX       lr
;;;32     //设置NVIC分组
                          ENDP

                  MY_NVIC_PriorityGroupConfig PROC
;;;35     //091209
;;;36     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
00000c  4601              MOV      r1,r0
;;;37     { 
;;;38     	u32 temp,temp1;	  
;;;39     	temp1=(~NVIC_Group)&0x07;//取后三位
00000e  2307              MOVS     r3,#7
000010  ea230201          BIC      r2,r3,r1
;;;40     	temp1<<=8;
000014  0212              LSLS     r2,r2,#8
;;;41     	temp=SCB->AIRCR;  //读取先前的设置
000016  4bac              LDR      r3,|L1.712|
000018  6818              LDR      r0,[r3,#0]
;;;42     	temp&=0X0000F8FF; //清空先前分组
00001a  f64f03ff          MOV      r3,#0xf8ff
00001e  ea000003          AND      r0,r0,r3
;;;43     	temp|=0X05FA0000; //写入钥匙
000022  4baa              LDR      r3,|L1.716|
000024  ea400003          ORR      r0,r0,r3
;;;44     	temp|=temp1;	   
000028  ea400002          ORR      r0,r0,r2
;;;45     	SCB->AIRCR=temp;  //设置分组	    	  				   
00002c  f04f23e0          MOV      r3,#0xe000e000
000030  f8c30d0c          STR      r0,[r3,#0xd0c]
;;;46     }
000034  4770              BX       lr
;;;47     //设置NVIC 
                          ENDP

                  MY_NVIC_Init PROC
;;;61     //100329
;;;62     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000036  e92d47f0          PUSH     {r4-r10,lr}
;;;63     { 
00003a  4680              MOV      r8,r0
00003c  4689              MOV      r9,r1
00003e  4614              MOV      r4,r2
000040  461d              MOV      r5,r3
;;;64     	u32 temp;	
;;;65     	u8 IPRADDR=NVIC_Channel/4;  //每组只能存4个,得到组地址 
000042  4620              MOV      r0,r4
000044  17e1              ASRS     r1,r4,#31
000046  eb047191          ADD      r1,r4,r1,LSR #30
00004a  ea4f0aa1          ASR      r10,r1,#2
;;;66     	u8 IPROFFSET=NVIC_Channel%4;//在组内的偏移
00004e  17e1              ASRS     r1,r4,#31
000050  eb047191          ADD      r1,r4,r1,LSR #30
000054  1089              ASRS     r1,r1,#2
000056  eba40181          SUB      r1,r4,r1,LSL #2
00005a  b2cf              UXTB     r7,r1
;;;67     	IPROFFSET=IPROFFSET*8+4;    //得到偏移的确切位置
00005c  2004              MOVS     r0,#4
00005e  eb0000c7          ADD      r0,r0,r7,LSL #3
000062  b2c7              UXTB     r7,r0
;;;68     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;69     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
00006a  f1c50004          RSB      r0,r5,#4
00006e  fa08f600          LSL      r6,r8,r0
;;;70     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
000072  200f              MOVS     r0,#0xf
000074  4128              ASRS     r0,r0,r5
000076  ea000009          AND      r0,r0,r9
00007a  4306              ORRS     r6,r6,r0
;;;71     	temp&=0xf;//取低四位
00007c  f006060f          AND      r6,r6,#0xf
;;;72     
;;;73     	if(NVIC_Channel<32)NVIC->ISER[0]|=1<<NVIC_Channel;//使能中断位(要清除的话,相反操作就OK)
000080  2c20              CMP      r4,#0x20
000082  da0c              BGE      |L1.158|
000084  4892              LDR      r0,|L1.720|
000086  6800              LDR      r0,[r0,#0]
000088  f04f0101          MOV      r1,#1
00008c  fa01f104          LSL      r1,r1,r4
000090  ea400001          ORR      r0,r0,r1
000094  f04f21e0          MOV      r1,#0xe000e000
000098  f8c10100          STR      r0,[r1,#0x100]
00009c  e00d              B        |L1.186|
                  |L1.158|
;;;74     	else NVIC->ISER[1]|=1<<(NVIC_Channel-32);    
00009e  488d              LDR      r0,|L1.724|
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f1a40120          SUB      r1,r4,#0x20
0000a6  f04f0201          MOV      r2,#1
0000aa  fa02f201          LSL      r2,r2,r1
0000ae  ea400002          ORR      r0,r0,r2
0000b2  f04f21e0          MOV      r1,#0xe000e000
0000b6  f8c10104          STR      r0,[r1,#0x104]
                  |L1.186|
;;;75     	NVIC->IPR[IPRADDR]|=temp<<IPROFFSET;//设置响应优先级和抢断优先级   	    	  				   
0000ba  4887              LDR      r0,|L1.728|
0000bc  f850002a          LDR      r0,[r0,r10,LSL #2]
0000c0  fa06f107          LSL      r1,r6,r7
0000c4  4308              ORRS     r0,r0,r1
0000c6  4984              LDR      r1,|L1.728|
0000c8  f841002a          STR      r0,[r1,r10,LSL #2]
;;;76     }
0000cc  e8bd87f0          POP      {r4-r10,pc}
;;;77     
                          ENDP

                  Ex_NVIC_Config PROC
;;;83     //待测试...
;;;84     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
0000d0  b570              PUSH     {r4-r6,lr}
;;;85     {
0000d2  4604              MOV      r4,r0
;;;86     	u8 EXTADDR;
;;;87     	u8 EXTOFFSET;
;;;88     	EXTADDR=BITx/4;//得到中断寄存器组的编号
0000d4  460b              MOV      r3,r1
0000d6  17ce              ASRS     r6,r1,#31
0000d8  eb017696          ADD      r6,r1,r6,LSR #30
0000dc  10b0              ASRS     r0,r6,#2
;;;89     	EXTOFFSET=(BITx%4)*4;
0000de  17ce              ASRS     r6,r1,#31
0000e0  eb017696          ADD      r6,r1,r6,LSR #30
0000e4  10b6              ASRS     r6,r6,#2
0000e6  eba10686          SUB      r6,r1,r6,LSL #2
0000ea  06b6              LSLS     r6,r6,#26
0000ec  0e35              LSRS     r5,r6,#24
;;;90     
;;;91     	RCC->APB2ENR|=0x01;//使能io复用时钟
0000ee  4b7b              LDR      r3,|L1.732|
0000f0  699b              LDR      r3,[r3,#0x18]
0000f2  f0430301          ORR      r3,r3,#1
0000f6  4e79              LDR      r6,|L1.732|
0000f8  61b3              STR      r3,[r6,#0x18]
;;;92     
;;;93     	AFIO->EXTICR[EXTADDR]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
0000fa  ea4f33b6          ROR      r3,r6,#14
0000fe  f8533020          LDR      r3,[r3,r0,LSL #2]
000102  260f              MOVS     r6,#0xf
000104  40ae              LSLS     r6,r6,r5
000106  43b3              BICS     r3,r3,r6
000108  4e75              LDR      r6,|L1.736|
00010a  f8463020          STR      r3,[r6,r0,LSL #2]
;;;94     	AFIO->EXTICR[EXTADDR]|=GPIOx<<EXTOFFSET;//EXTI.BITx映射到GPIOx.BITx
00010e  4633              MOV      r3,r6
000110  f8533020          LDR      r3,[r3,r0,LSL #2]
000114  fa04f605          LSL      r6,r4,r5
000118  4333              ORRS     r3,r3,r6
00011a  4e71              LDR      r6,|L1.736|
00011c  f8463020          STR      r3,[r6,r0,LSL #2]
;;;95     	
;;;96     	//自动设置
;;;97     	EXTI->IMR|=1<<BITx;//  开启line BITx上的中断
000120  4b70              LDR      r3,|L1.740|
000122  681e              LDR      r6,[r3,#0]
000124  f04f0301          MOV      r3,#1
000128  fa03f301          LSL      r3,r3,r1
00012c  ea460603          ORR      r6,r6,r3
000130  4b6d              LDR      r3,|L1.744|
000132  f8c36400          STR      r6,[r3,#0x400]
;;;98     	//EXTI->EMR|=1<<BITx;//不屏蔽line BITx上的事件 (如果不屏蔽这句,在硬件上是可以的,但是在软件仿真的时候无法进入中断!)
;;;99      	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;//line BITx上事件下降沿触发
000136  f0120f01          TST      r2,#1
00013a  d00a              BEQ      |L1.338|
00013c  4b6b              LDR      r3,|L1.748|
00013e  681b              LDR      r3,[r3,#0]
000140  f04f0601          MOV      r6,#1
000144  fa06f601          LSL      r6,r6,r1
000148  ea430306          ORR      r3,r3,r6
00014c  4e66              LDR      r6,|L1.744|
00014e  f8c6340c          STR      r3,[r6,#0x40c]
                  |L1.338|
;;;100    	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;//line BITx上事件上升降沿触发
000152  f0120f02          TST      r2,#2
000156  d00a              BEQ      |L1.366|
000158  4b65              LDR      r3,|L1.752|
00015a  681b              LDR      r3,[r3,#0]
00015c  f04f0601          MOV      r6,#1
000160  fa06f601          LSL      r6,r6,r1
000164  ea430306          ORR      r3,r3,r6
000168  4e5f              LDR      r6,|L1.744|
00016a  f8c63408          STR      r3,[r6,#0x408]
                  |L1.366|
;;;101    } 
00016e  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

                  MYRCC_DeInit PROC
;;;107    //091209
;;;108    void MYRCC_DeInit(void)
000170  b500              PUSH     {lr}
;;;109    {										  					   
;;;110    	RCC->APB1RSTR = 0x00000000;//复位结束			 
000172  2000              MOVS     r0,#0
000174  4959              LDR      r1,|L1.732|
000176  6108              STR      r0,[r1,#0x10]
;;;111    	RCC->APB2RSTR = 0x00000000; 
000178  60c8              STR      r0,[r1,#0xc]
;;;112    	  
;;;113      	RCC->AHBENR = 0x00000014;  //睡眠模式闪存和SRAM时钟使能.其他关闭.	  
00017a  2014              MOVS     r0,#0x14
00017c  6148              STR      r0,[r1,#0x14]
;;;114      	RCC->APB2ENR = 0x00000000; //外设时钟关闭.			   
00017e  2000              MOVS     r0,#0
000180  6188              STR      r0,[r1,#0x18]
;;;115      	RCC->APB1ENR = 0x00000000;   
000182  61c8              STR      r0,[r1,#0x1c]
;;;116    	RCC->CR |= 0x00000001;     //使能内部高速时钟HSION	 															 
000184  4608              MOV      r0,r1
000186  6800              LDR      r0,[r0,#0]
000188  f0400001          ORR      r0,r0,#1
00018c  6008              STR      r0,[r1,#0]
;;;117    	RCC->CFGR &= 0xF8FF0000;   //复位SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]					 
00018e  4608              MOV      r0,r1
000190  6840              LDR      r0,[r0,#4]
000192  4958              LDR      r1,|L1.756|
000194  4008              ANDS     r0,r0,r1
000196  4951              LDR      r1,|L1.732|
000198  6048              STR      r0,[r1,#4]
;;;118    	RCC->CR &= 0xFEF6FFFF;     //复位HSEON,CSSON,PLLON
00019a  4608              MOV      r0,r1
00019c  6800              LDR      r0,[r0,#0]
00019e  4956              LDR      r1,|L1.760|
0001a0  4008              ANDS     r0,r0,r1
0001a2  494e              LDR      r1,|L1.732|
0001a4  6008              STR      r0,[r1,#0]
;;;119    	RCC->CR &= 0xFFFBFFFF;     //复位HSEBYP	   	  
0001a6  4608              MOV      r0,r1
0001a8  6800              LDR      r0,[r0,#0]
0001aa  f4202080          BIC      r0,r0,#0x40000
0001ae  6008              STR      r0,[r1,#0]
;;;120    	RCC->CFGR &= 0xFF80FFFF;   //复位PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE 
0001b0  4608              MOV      r0,r1
0001b2  6840              LDR      r0,[r0,#4]
0001b4  f42000fe          BIC      r0,r0,#0x7f0000
0001b8  6048              STR      r0,[r1,#4]
;;;121    	RCC->CIR = 0x00000000;     //关闭所有中断
0001ba  2000              MOVS     r0,#0
0001bc  6088              STR      r0,[r1,#8]
;;;122    	//配置向量表				  
;;;123    #ifdef  VECT_TAB_RAM
;;;124    	MY_NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;125    #else   
;;;126    	MY_NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
0001be  2100              MOVS     r1,#0
0001c0  f04f6000          MOV      r0,#0x8000000
0001c4  f7fffffe          BL       MY_NVIC_SetVectorTable
;;;127    #endif
;;;128    }
0001c8  bd00              POP      {pc}
;;;129    //THUMB指令不支持汇编内联
                          ENDP

                  Sys_Standby PROC
;;;139    //091202
;;;140    void Sys_Standby(void)
0001ca  b510              PUSH     {r4,lr}
;;;141    {
;;;142    	SCB->SCR|=1<<2;//使能SLEEPDEEP位 (SYS->CTRL)	   
0001cc  484b              LDR      r0,|L1.764|
0001ce  6800              LDR      r0,[r0,#0]
0001d0  f0400004          ORR      r0,r0,#4
0001d4  f04f21e0          MOV      r1,#0xe000e000
0001d8  f8c10d10          STR      r0,[r1,#0xd10]
;;;143      	RCC->APB1ENR|=1<<28;     //使能电源时钟	    
0001dc  483f              LDR      r0,|L1.732|
0001de  69c0              LDR      r0,[r0,#0x1c]
0001e0  f0405080          ORR      r0,r0,#0x10000000
0001e4  493d              LDR      r1,|L1.732|
0001e6  61c8              STR      r0,[r1,#0x1c]
;;;144     	PWR->CSR|=1<<8;          //设置WKUP用于唤醒
0001e8  4845              LDR      r0,|L1.768|
0001ea  6840              LDR      r0,[r0,#4]
0001ec  f4407080          ORR      r0,r0,#0x100
0001f0  4943              LDR      r1,|L1.768|
0001f2  6048              STR      r0,[r1,#4]
;;;145    	PWR->CR|=1<<2;           //清除Wake-up 标志
0001f4  4608              MOV      r0,r1
0001f6  6800              LDR      r0,[r0,#0]
0001f8  f0400004          ORR      r0,r0,#4
0001fc  6008              STR      r0,[r1,#0]
;;;146    	PWR->CR|=1<<1;           //PDDS置位		  
0001fe  4608              MOV      r0,r1
000200  6800              LDR      r0,[r0,#0]
000202  f0400002          ORR      r0,r0,#2
000206  6008              STR      r0,[r1,#0]
;;;147    	WFI_SET();				 //执行WFI指令		 
000208  f7fffffe          BL       WFI_SET
;;;148    }	  
00020c  bd10              POP      {r4,pc}
;;;149    //后备寄存器写入操作
                          ENDP

                  Sys_Soft_Reset PROC
;;;195    //091209
;;;196    void Sys_Soft_Reset(void)
00020e  482f              LDR      r0,|L1.716|
;;;197    {   
;;;198    	SCB->AIRCR =0X05FA0000|(u32)0x04;	  
000210  1d00              ADDS     r0,r0,#4
000212  492d              LDR      r1,|L1.712|
000214  6008              STR      r0,[r1,#0]
;;;199    } 
000216  4770              BX       lr
;;;200    
                          ENDP

                  JTAG_Set PROC
;;;204    //100818		  
;;;205    void JTAG_Set(u8 mode)
000218  4601              MOV      r1,r0
;;;206    {
;;;207    	u32 temp;
;;;208    	temp=mode;
;;;209    	temp<<=25;
00021a  0649              LSLS     r1,r1,#25
;;;210    	RCC->APB2ENR|=1<<0;     //开启辅助时钟	   
00021c  4a2f              LDR      r2,|L1.732|
00021e  6992              LDR      r2,[r2,#0x18]
000220  f0420201          ORR      r2,r2,#1
000224  4b2d              LDR      r3,|L1.732|
000226  619a              STR      r2,[r3,#0x18]
;;;211    	AFIO->MAPR&=0XF8FFFFFF; //清除MAPR的[26:24]
000228  4a2f              LDR      r2,|L1.744|
00022a  6852              LDR      r2,[r2,#4]
00022c  f02262e0          BIC      r2,r2,#0x7000000
000230  4b2d              LDR      r3,|L1.744|
000232  605a              STR      r2,[r3,#4]
;;;212    	AFIO->MAPR|=temp;       //设置jtag模式
000234  461a              MOV      r2,r3
000236  6852              LDR      r2,[r2,#4]
000238  430a              ORRS     r2,r2,r1
00023a  605a              STR      r2,[r3,#4]
;;;213    } 
00023c  4770              BX       lr
;;;214    //系统时钟初始化函数
                          ENDP

                  Stm32_Clock_Init PROC
;;;217    //091209
;;;218    void Stm32_Clock_Init(u8 PLL)
00023e  b530              PUSH     {r4,r5,lr}
;;;219    {
000240  4604              MOV      r4,r0
;;;220    	unsigned char temp=0;   
000242  2500              MOVS     r5,#0
;;;221    	MYRCC_DeInit();		  //复位并配置向量表
000244  f7fffffe          BL       MYRCC_DeInit
;;;222    	RCC->CR|=0x00010000;  //外部高速时钟使能HSEON
000248  4824              LDR      r0,|L1.732|
00024a  6800              LDR      r0,[r0,#0]
00024c  f4403080          ORR      r0,r0,#0x10000
000250  4922              LDR      r1,|L1.732|
000252  6008              STR      r0,[r1,#0]
;;;223    	while(!(RCC->CR>>17));//等待外部时钟就绪
000254  bf00              NOP      
                  |L1.598|
000256  4821              LDR      r0,|L1.732|
000258  6800              LDR      r0,[r0,#0]
00025a  0c40              LSRS     r0,r0,#17
00025c  d0fb              BEQ      |L1.598|
;;;224    	RCC->CFGR=0X00000400; //APB1=DIV2;APB2=DIV1;AHB=DIV1;
00025e  f44f6080          MOV      r0,#0x400
000262  491e              LDR      r1,|L1.732|
000264  6048              STR      r0,[r1,#4]
;;;225    	PLL-=2;//抵消2个单位
000266  1ea0              SUBS     r0,r4,#2
000268  b2c4              UXTB     r4,r0
;;;226    	RCC->CFGR|=PLL<<18;   //设置PLL值 2~16
00026a  4608              MOV      r0,r1
00026c  6840              LDR      r0,[r0,#4]
00026e  ea404084          ORR      r0,r0,r4,LSL #18
000272  6048              STR      r0,[r1,#4]
;;;227    	RCC->CFGR|=1<<16;	  //PLLSRC ON 
000274  4608              MOV      r0,r1
000276  6840              LDR      r0,[r0,#4]
000278  f4403080          ORR      r0,r0,#0x10000
00027c  6048              STR      r0,[r1,#4]
;;;228    	FLASH->ACR|=0x32;	  //FLASH 2个延时周期
00027e  4821              LDR      r0,|L1.772|
000280  6800              LDR      r0,[r0,#0]
000282  f0400032          ORR      r0,r0,#0x32
000286  491f              LDR      r1,|L1.772|
000288  6008              STR      r0,[r1,#0]
;;;229    
;;;230    	RCC->CR|=0x01000000;  //PLLON
00028a  4814              LDR      r0,|L1.732|
00028c  6800              LDR      r0,[r0,#0]
00028e  f0407080          ORR      r0,r0,#0x1000000
000292  4912              LDR      r1,|L1.732|
000294  6008              STR      r0,[r1,#0]
;;;231    	while(!(RCC->CR>>25));//等待PLL锁定
000296  bf00              NOP      
                  |L1.664|
000298  4810              LDR      r0,|L1.732|
00029a  6800              LDR      r0,[r0,#0]
00029c  0e40              LSRS     r0,r0,#25
00029e  d0fb              BEQ      |L1.664|
;;;232    	RCC->CFGR|=0x00000002;//PLL作为系统时钟	 
0002a0  480e              LDR      r0,|L1.732|
0002a2  6840              LDR      r0,[r0,#4]
0002a4  f0400002          ORR      r0,r0,#2
0002a8  490c              LDR      r1,|L1.732|
0002aa  6048              STR      r0,[r1,#4]
;;;233    	while(temp!=0x02)     //等待PLL作为系统时钟设置成功
0002ac  e005              B        |L1.698|
                  |L1.686|
;;;234    	{   
;;;235    		temp=RCC->CFGR>>2;
0002ae  480b              LDR      r0,|L1.732|
0002b0  6840              LDR      r0,[r0,#4]
0002b2  f3c00587          UBFX     r5,r0,#2,#8
;;;236    		temp&=0x03;
0002b6  f0050503          AND      r5,r5,#3
                  |L1.698|
0002ba  2d02              CMP      r5,#2                 ;233
0002bc  d1f7              BNE      |L1.686|
;;;237    	}    
;;;238    }		    
0002be  bd30              POP      {r4,r5,pc}
;;;239    
                          ENDP

                  |L1.704|
                          DCD      0x1fffff80
                  |L1.708|
                          DCD      0xe000ed08
                  |L1.712|
                          DCD      0xe000ed0c
                  |L1.716|
                          DCD      0x05fa0000
                  |L1.720|
                          DCD      0xe000e100
                  |L1.724|
                          DCD      0xe000e104
                  |L1.728|
                          DCD      0xe000e400
                  |L1.732|
                          DCD      0x40021000
                  |L1.736|
                          DCD      0x40010008
                  |L1.740|
                          DCD      0x40010400
                  |L1.744|
                          DCD      0x40010000
                  |L1.748|
                          DCD      0x4001040c
                  |L1.752|
                          DCD      0x40010408
                  |L1.756|
                          DCD      0xf8ff0000
                  |L1.760|
                          DCD      0xfef6ffff
                  |L1.764|
                          DCD      0xe000ed10
                  |L1.768|
                          DCD      0x40007000
                  |L1.772|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\sys\\sys.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |WFI_SET|
#line 133
|WFI_SET| PROC
#line 134

 WFI
	ENDP

;*** End   embedded assembler ***
